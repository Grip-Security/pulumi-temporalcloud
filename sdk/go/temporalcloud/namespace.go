// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package temporalcloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/Grip-Security/pulumi-temporalcloud/sdk/go/temporalcloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provisions a Temporal Cloud namespace.
//
// ## Import
//
// Namespace can be imported to incorporate existing Namespaces into your Terraform pipeline.
//
// # To import a Namespace, you need
//
// - a resource configuration in your Terraform configuration file/module to accept the imported Namespace. In the example below, the placeholder is "temporalcloud_namespace" "terraform"
//
// - the Namespace ID, which includes the Namespace Name and Account ID available at the top of the Namespace's page in the Temporal Cloud UI. In the example below, this is namespaceid.acctid
//
// ```sh
// $ pulumi import temporalcloud:index/namespace:Namespace terraform namespaceid.acctid
// ```
type Namespace struct {
	pulumi.CustomResourceState

	// The Base64-encoded CA cert in PEM format that clients use when authenticating with Temporal Cloud. This is a required field when a Namespace uses mTLS authentication.
	AcceptedClientCa pulumi.StringPtrOutput `pulumi:"acceptedClientCa"`
	// If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
	ApiKeyAuth pulumi.BoolOutput `pulumi:"apiKeyAuth"`
	// A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters. Empty lists are not allowed, omit the attribute instead.
	CertificateFilters NamespaceCertificateFilterArrayOutput `pulumi:"certificateFilters"`
	// A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
	CodecServer NamespaceCodecServerPtrOutput `pulumi:"codecServer"`
	// The endpoints for the namespace.
	Endpoints NamespaceEndpointsOutput `pulumi:"endpoints"`
	// The name of the namespace.
	Name    pulumi.StringOutput      `pulumi:"name"`
	Regions pulumi.StringArrayOutput `pulumi:"regions"`
	// The number of days to retain workflow history. Any changes to the retention period will be applied to all new running workflows.
	RetentionDays pulumi.IntOutput           `pulumi:"retentionDays"`
	Timeouts      NamespaceTimeoutsPtrOutput `pulumi:"timeouts"`
}

// NewNamespace registers a new resource with the given unique name, arguments, and options.
func NewNamespace(ctx *pulumi.Context,
	name string, args *NamespaceArgs, opts ...pulumi.ResourceOption) (*Namespace, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Regions == nil {
		return nil, errors.New("invalid value for required argument 'Regions'")
	}
	if args.RetentionDays == nil {
		return nil, errors.New("invalid value for required argument 'RetentionDays'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Namespace
	err := ctx.RegisterResource("temporalcloud:index/namespace:Namespace", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNamespace gets an existing Namespace resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNamespace(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NamespaceState, opts ...pulumi.ResourceOption) (*Namespace, error) {
	var resource Namespace
	err := ctx.ReadResource("temporalcloud:index/namespace:Namespace", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Namespace resources.
type namespaceState struct {
	// The Base64-encoded CA cert in PEM format that clients use when authenticating with Temporal Cloud. This is a required field when a Namespace uses mTLS authentication.
	AcceptedClientCa *string `pulumi:"acceptedClientCa"`
	// If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
	ApiKeyAuth *bool `pulumi:"apiKeyAuth"`
	// A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters. Empty lists are not allowed, omit the attribute instead.
	CertificateFilters []NamespaceCertificateFilter `pulumi:"certificateFilters"`
	// A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
	CodecServer *NamespaceCodecServer `pulumi:"codecServer"`
	// The endpoints for the namespace.
	Endpoints *NamespaceEndpoints `pulumi:"endpoints"`
	// The name of the namespace.
	Name    *string  `pulumi:"name"`
	Regions []string `pulumi:"regions"`
	// The number of days to retain workflow history. Any changes to the retention period will be applied to all new running workflows.
	RetentionDays *int               `pulumi:"retentionDays"`
	Timeouts      *NamespaceTimeouts `pulumi:"timeouts"`
}

type NamespaceState struct {
	// The Base64-encoded CA cert in PEM format that clients use when authenticating with Temporal Cloud. This is a required field when a Namespace uses mTLS authentication.
	AcceptedClientCa pulumi.StringPtrInput
	// If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
	ApiKeyAuth pulumi.BoolPtrInput
	// A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters. Empty lists are not allowed, omit the attribute instead.
	CertificateFilters NamespaceCertificateFilterArrayInput
	// A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
	CodecServer NamespaceCodecServerPtrInput
	// The endpoints for the namespace.
	Endpoints NamespaceEndpointsPtrInput
	// The name of the namespace.
	Name    pulumi.StringPtrInput
	Regions pulumi.StringArrayInput
	// The number of days to retain workflow history. Any changes to the retention period will be applied to all new running workflows.
	RetentionDays pulumi.IntPtrInput
	Timeouts      NamespaceTimeoutsPtrInput
}

func (NamespaceState) ElementType() reflect.Type {
	return reflect.TypeOf((*namespaceState)(nil)).Elem()
}

type namespaceArgs struct {
	// The Base64-encoded CA cert in PEM format that clients use when authenticating with Temporal Cloud. This is a required field when a Namespace uses mTLS authentication.
	AcceptedClientCa *string `pulumi:"acceptedClientCa"`
	// If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
	ApiKeyAuth *bool `pulumi:"apiKeyAuth"`
	// A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters. Empty lists are not allowed, omit the attribute instead.
	CertificateFilters []NamespaceCertificateFilter `pulumi:"certificateFilters"`
	// A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
	CodecServer *NamespaceCodecServer `pulumi:"codecServer"`
	// The name of the namespace.
	Name    *string  `pulumi:"name"`
	Regions []string `pulumi:"regions"`
	// The number of days to retain workflow history. Any changes to the retention period will be applied to all new running workflows.
	RetentionDays int                `pulumi:"retentionDays"`
	Timeouts      *NamespaceTimeouts `pulumi:"timeouts"`
}

// The set of arguments for constructing a Namespace resource.
type NamespaceArgs struct {
	// The Base64-encoded CA cert in PEM format that clients use when authenticating with Temporal Cloud. This is a required field when a Namespace uses mTLS authentication.
	AcceptedClientCa pulumi.StringPtrInput
	// If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
	ApiKeyAuth pulumi.BoolPtrInput
	// A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters. Empty lists are not allowed, omit the attribute instead.
	CertificateFilters NamespaceCertificateFilterArrayInput
	// A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
	CodecServer NamespaceCodecServerPtrInput
	// The name of the namespace.
	Name    pulumi.StringPtrInput
	Regions pulumi.StringArrayInput
	// The number of days to retain workflow history. Any changes to the retention period will be applied to all new running workflows.
	RetentionDays pulumi.IntInput
	Timeouts      NamespaceTimeoutsPtrInput
}

func (NamespaceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*namespaceArgs)(nil)).Elem()
}

type NamespaceInput interface {
	pulumi.Input

	ToNamespaceOutput() NamespaceOutput
	ToNamespaceOutputWithContext(ctx context.Context) NamespaceOutput
}

func (*Namespace) ElementType() reflect.Type {
	return reflect.TypeOf((**Namespace)(nil)).Elem()
}

func (i *Namespace) ToNamespaceOutput() NamespaceOutput {
	return i.ToNamespaceOutputWithContext(context.Background())
}

func (i *Namespace) ToNamespaceOutputWithContext(ctx context.Context) NamespaceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceOutput)
}

// NamespaceArrayInput is an input type that accepts NamespaceArray and NamespaceArrayOutput values.
// You can construct a concrete instance of `NamespaceArrayInput` via:
//
//	NamespaceArray{ NamespaceArgs{...} }
type NamespaceArrayInput interface {
	pulumi.Input

	ToNamespaceArrayOutput() NamespaceArrayOutput
	ToNamespaceArrayOutputWithContext(context.Context) NamespaceArrayOutput
}

type NamespaceArray []NamespaceInput

func (NamespaceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Namespace)(nil)).Elem()
}

func (i NamespaceArray) ToNamespaceArrayOutput() NamespaceArrayOutput {
	return i.ToNamespaceArrayOutputWithContext(context.Background())
}

func (i NamespaceArray) ToNamespaceArrayOutputWithContext(ctx context.Context) NamespaceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceArrayOutput)
}

// NamespaceMapInput is an input type that accepts NamespaceMap and NamespaceMapOutput values.
// You can construct a concrete instance of `NamespaceMapInput` via:
//
//	NamespaceMap{ "key": NamespaceArgs{...} }
type NamespaceMapInput interface {
	pulumi.Input

	ToNamespaceMapOutput() NamespaceMapOutput
	ToNamespaceMapOutputWithContext(context.Context) NamespaceMapOutput
}

type NamespaceMap map[string]NamespaceInput

func (NamespaceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Namespace)(nil)).Elem()
}

func (i NamespaceMap) ToNamespaceMapOutput() NamespaceMapOutput {
	return i.ToNamespaceMapOutputWithContext(context.Background())
}

func (i NamespaceMap) ToNamespaceMapOutputWithContext(ctx context.Context) NamespaceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NamespaceMapOutput)
}

type NamespaceOutput struct{ *pulumi.OutputState }

func (NamespaceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Namespace)(nil)).Elem()
}

func (o NamespaceOutput) ToNamespaceOutput() NamespaceOutput {
	return o
}

func (o NamespaceOutput) ToNamespaceOutputWithContext(ctx context.Context) NamespaceOutput {
	return o
}

// The Base64-encoded CA cert in PEM format that clients use when authenticating with Temporal Cloud. This is a required field when a Namespace uses mTLS authentication.
func (o NamespaceOutput) AcceptedClientCa() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Namespace) pulumi.StringPtrOutput { return v.AcceptedClientCa }).(pulumi.StringPtrOutput)
}

// If true, Temporal Cloud will use API key authentication for this namespace. If false, mutual TLS (mTLS) authentication will be used.
func (o NamespaceOutput) ApiKeyAuth() pulumi.BoolOutput {
	return o.ApplyT(func(v *Namespace) pulumi.BoolOutput { return v.ApiKeyAuth }).(pulumi.BoolOutput)
}

// A list of filters to apply to client certificates when initiating a connection Temporal Cloud. If present, connections will only be allowed from client certificates whose distinguished name properties match at least one of the filters. Empty lists are not allowed, omit the attribute instead.
func (o NamespaceOutput) CertificateFilters() NamespaceCertificateFilterArrayOutput {
	return o.ApplyT(func(v *Namespace) NamespaceCertificateFilterArrayOutput { return v.CertificateFilters }).(NamespaceCertificateFilterArrayOutput)
}

// A codec server is used by the Temporal Cloud UI to decode payloads for all users interacting with this namespace, even if the workflow history itself is encrypted.
func (o NamespaceOutput) CodecServer() NamespaceCodecServerPtrOutput {
	return o.ApplyT(func(v *Namespace) NamespaceCodecServerPtrOutput { return v.CodecServer }).(NamespaceCodecServerPtrOutput)
}

// The endpoints for the namespace.
func (o NamespaceOutput) Endpoints() NamespaceEndpointsOutput {
	return o.ApplyT(func(v *Namespace) NamespaceEndpointsOutput { return v.Endpoints }).(NamespaceEndpointsOutput)
}

// The name of the namespace.
func (o NamespaceOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Namespace) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o NamespaceOutput) Regions() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Namespace) pulumi.StringArrayOutput { return v.Regions }).(pulumi.StringArrayOutput)
}

// The number of days to retain workflow history. Any changes to the retention period will be applied to all new running workflows.
func (o NamespaceOutput) RetentionDays() pulumi.IntOutput {
	return o.ApplyT(func(v *Namespace) pulumi.IntOutput { return v.RetentionDays }).(pulumi.IntOutput)
}

func (o NamespaceOutput) Timeouts() NamespaceTimeoutsPtrOutput {
	return o.ApplyT(func(v *Namespace) NamespaceTimeoutsPtrOutput { return v.Timeouts }).(NamespaceTimeoutsPtrOutput)
}

type NamespaceArrayOutput struct{ *pulumi.OutputState }

func (NamespaceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Namespace)(nil)).Elem()
}

func (o NamespaceArrayOutput) ToNamespaceArrayOutput() NamespaceArrayOutput {
	return o
}

func (o NamespaceArrayOutput) ToNamespaceArrayOutputWithContext(ctx context.Context) NamespaceArrayOutput {
	return o
}

func (o NamespaceArrayOutput) Index(i pulumi.IntInput) NamespaceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Namespace {
		return vs[0].([]*Namespace)[vs[1].(int)]
	}).(NamespaceOutput)
}

type NamespaceMapOutput struct{ *pulumi.OutputState }

func (NamespaceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Namespace)(nil)).Elem()
}

func (o NamespaceMapOutput) ToNamespaceMapOutput() NamespaceMapOutput {
	return o
}

func (o NamespaceMapOutput) ToNamespaceMapOutputWithContext(ctx context.Context) NamespaceMapOutput {
	return o
}

func (o NamespaceMapOutput) MapIndex(k pulumi.StringInput) NamespaceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Namespace {
		return vs[0].(map[string]*Namespace)[vs[1].(string)]
	}).(NamespaceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceInput)(nil)).Elem(), &Namespace{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceArrayInput)(nil)).Elem(), NamespaceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NamespaceMapInput)(nil)).Elem(), NamespaceMap{})
	pulumi.RegisterOutputType(NamespaceOutput{})
	pulumi.RegisterOutputType(NamespaceArrayOutput{})
	pulumi.RegisterOutputType(NamespaceMapOutput{})
}
